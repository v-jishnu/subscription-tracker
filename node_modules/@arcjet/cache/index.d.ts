/**
 * Interface for a cache.
 */
export interface Cache<T = unknown> {
    /**
     * Retrieve a value from the cache;
     * it will be returned with the remaining time-to-live (in seconds) if it exists.
     *
     * @param namespace
     *   Isolated segment of the cache where keys are tracked.
     * @param key
     *   Key.
     * @returns
     *   Promise for a tuple with the value and TTL in seconds;
     *   value will be `undefined` and TTL will be `0` if not found.
     */
    get(namespace: string, key: string): Promise<[T | undefined, number]>;
    /**
     * Store a value in the cache.
     *
     * @param namespace
     *   Isolated segment of the cache where keys are tracked.
     * @param key
     *   Key.
     * @param value
     *   Value.
     * @param ttl
     *   Number of seconds the entry stays valid.
     * @returns
     *   Nothing.
     */
    set(namespace: string, key: string, value: T, ttl: number): void;
}
declare class Bucket<T> {
    expires: Map<string, number>;
    data: Map<string, T>;
    constructor();
    get(key: string): [T | undefined, number];
    set(key: string, value: T, ttl: number): void;
}
/**
 * In-memory cache.
 */
export declare class MemoryCache<T> implements Cache<T> {
    /**
     * Data.
     */
    namespaces: Map<string, Bucket<T>>;
    /**
     * Create a new in-memory cache.
     */
    constructor();
    get(namespace: string, key: string): Promise<[T | undefined, number]>;
    set(namespace: string, key: string, value: T, ttl: number): void;
}
export {};
