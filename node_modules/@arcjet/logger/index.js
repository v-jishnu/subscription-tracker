import format from '@arcjet/sprintf';

function bigintReplacer(key, value) {
    if (typeof value === "bigint") {
        return "[BigInt]";
    }
    return value;
}
// TODO: Deduplicate this and sprintf implementation
function tryStringify(value) {
    try {
        return JSON.stringify(value, bigintReplacer);
    }
    catch {
        return "[Circular]";
    }
}
const PREFIX = "âœ¦Aj";
function getMessage(mergingObject, message, interpolationValues) {
    // The first argument was the message so juggle the arguments
    if (typeof mergingObject === "string") {
        interpolationValues = [message, ...interpolationValues];
        message = mergingObject;
    }
    // Prefer a string message over `mergingObject.msg`, as per Pino:
    // https://github.com/pinojs/pino/blob/8db130eba0439e61c802448d31eb1998cebfbc98/docs/api.md#message-string
    if (typeof message === "string") {
        return format(message, ...interpolationValues);
    }
    if (typeof mergingObject === "object" &&
        mergingObject !== null &&
        "msg" in mergingObject &&
        typeof mergingObject.msg === "string") {
        return format(mergingObject.msg, [message, ...interpolationValues]);
    }
}
function getOutput(messageOrObject, message, interpolationValues) {
    let output = getMessage(messageOrObject, message, interpolationValues);
    if (typeof output !== "string") {
        return;
    }
    if (typeof messageOrObject === "object" && messageOrObject !== null) {
        for (const [key, value] of Object.entries(messageOrObject)) {
            output += `\n      ${key}: ${tryStringify(value)}`;
        }
    }
    return output;
}
/**
 * Logger.
 */
class Logger {
    #logLevel;
    /**
     * Configuration.
     *
     * @param options
     *   Configuration.
     * @returns
     *   Logger.
     */
    constructor(options) {
        if (typeof options.level !== "string") {
            throw new Error(`Invalid log level`);
        }
        switch (options.level) {
            case "debug":
                this.#logLevel = 0;
                break;
            case "info":
                this.#logLevel = 1;
                break;
            case "warn":
                this.#logLevel = 2;
                break;
            case "error":
                this.#logLevel = 3;
                break;
            default: {
                throw new Error(`Unknown log level: ${options.level}`);
            }
        }
    }
    debug(messageOrObject, message, ...interpolationValues) {
        if (this.#logLevel <= 0) {
            const output = getOutput(messageOrObject, message, interpolationValues);
            if (typeof output !== "undefined") {
                console.debug(`${PREFIX} DEBUG ${output}`);
            }
        }
    }
    info(messageOrObject, message, ...interpolationValues) {
        if (this.#logLevel <= 1) {
            const output = getOutput(messageOrObject, message, interpolationValues);
            if (typeof output !== "undefined") {
                console.info(`${PREFIX} INFO ${output}`);
            }
        }
    }
    warn(messageOrObject, message, ...interpolationValues) {
        if (this.#logLevel <= 2) {
            const output = getOutput(messageOrObject, message, interpolationValues);
            if (typeof output !== "undefined") {
                console.warn(`${PREFIX} WARN ${output}`);
            }
        }
    }
    error(messageOrObject, message, ...interpolationValues) {
        if (this.#logLevel <= 3) {
            const output = getOutput(messageOrObject, message, interpolationValues);
            if (typeof output !== "undefined") {
                console.error(`${PREFIX} ERROR ${output}`);
            }
        }
    }
}

export { Logger };
