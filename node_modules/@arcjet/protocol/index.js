import { typeid } from 'typeid-js';
import { Reason } from './proto/decide/v1alpha1/decide_pb.js';
export { categories as botCategories } from './well-known-bots.js';

/**
 * Reason returned by a rule.
 */
class ArcjetReason {
    /**
     * Kind.
     */
    type;
    /**
     * Check if this reason is a sensitive info reason.
     *
     * @returns
     *   Whether this reason is a sensitive info reason.
     */
    isSensitiveInfo() {
        return this.type === "SENSITIVE_INFO";
    }
    /**
     * Check if this reason is a rate limit reason.
     *
     * @returns
     *   Whether this reason is a rate limit reason.
     */
    isRateLimit() {
        return this.type === "RATE_LIMIT";
    }
    /**
     * Check if this reason is a bot reason.
     *
     * @returns
     *   Whether this reason is a bot reason.
     */
    isBot() {
        return this.type === "BOT";
    }
    /**
     * Check if this reason is an edge rule reason.
     *
     * @returns
     *   Whether this reason is an edge rule reason.
     */
    isEdgeRule() {
        return this.type === "EDGE_RULE";
    }
    /**
     * Check if this reason is a shield reason.
     *
     * @returns
     *   Whether this reason is a shield reason.
     */
    isShield() {
        return this.type === "SHIELD";
    }
    /**
     * Check if this reason is an email reason.
     *
     * @returns
     *   Whether this reason is an email reason.
     */
    isEmail() {
        return this.type === "EMAIL";
    }
    /**
     * Check if this reason is an error reason.
     *
     * @returns
     *   Whether this reason is an error reason.
     */
    isError() {
        return this.type === "ERROR";
    }
    /**
     * Check if this is a filter reason.
     *
     * @returns
     *   Whether this is a filter reason.
     */
    isFilter() {
        return this.type === "FILTER";
    }
}
/**
 * Filter reason.
 */
class ArcjetFilterReason extends ArcjetReason {
    /**
     * Expressions that matched.
     */
    matchedExpressions;
    /**
     * Kind.
     */
    type = "FILTER";
    /**
     * Expression that could not be matched.
     */
    undeterminedExpressions;
    /**
     * Create a filter reason.
     *
     * @param init
     *   Expression that matched.
     * @returns
     *   Filter reason.
     */
    constructor(init) {
        super();
        this.matchedExpressions = init.matchedExpressions;
        this.undeterminedExpressions = init.undeterminedExpressions;
    }
}
/**
 * Sensitive info reason.
 */
class ArcjetSensitiveInfoReason extends ArcjetReason {
    /**
     * Kind.
     */
    type = "SENSITIVE_INFO";
    /**
     * List of denied entities.
     */
    denied;
    /**
     * List of allowed entities.
     */
    allowed;
    /**
     * Create an `ArcjetSensitiveInfoReason`.
     *
     * @param init
     *   Configuration.
     * @returns
     *   Sensitive info reason.
     */
    constructor(init) {
        super();
        this.denied = init.denied;
        this.allowed = init.allowed;
    }
}
/**
 * Rate limit reason.
 */
class ArcjetRateLimitReason extends ArcjetReason {
    /**
     * Kind.
     */
    type = "RATE_LIMIT";
    /**
     * Maximum number of allowed requests.
     */
    max;
    /**
     * Remaining number of requests.
     */
    remaining;
    /**
     * Time in seconds until reset.
     */
    reset;
    /**
     * Time in seconds until the window resets.
     */
    window;
    /**
     * Time when the rate limit resets.
     */
    resetTime;
    /**
     * Create an `ArcjetRateLimitReason`.
     *
     * @param init
     *   Configuration.
     * @returns
     *   Rate limit reason.
     */
    constructor(init) {
        super();
        this.max = init.max;
        this.remaining = init.remaining;
        this.reset = init.reset;
        this.window = init.window;
        this.resetTime = init.resetTime;
    }
}
/**
 * Bot reason.
 */
class ArcjetBotReason extends ArcjetReason {
    /**
     * Kind.
     */
    type = "BOT";
    /**
     * List of allowed bot identifiers.
     */
    allowed;
    /**
     * List of denied bot identifiers.
     */
    denied;
    /**
     * Whether the bot is verified.
     */
    verified;
    /**
     * Whether the bot is spoofed.
     */
    spoofed;
    /**
     * Create an `ArcjetBotReason`.
     *
     * @param init
     *   Configuration.
     * @returns
     *   Bot reason.
     */
    constructor(init) {
        super();
        this.allowed = init.allowed;
        this.denied = init.denied;
        this.verified = init.verified;
        this.spoofed = init.spoofed;
    }
    /**
     * Check if the bot is verified.
     *
     * @returns
     *   Whether the bot is verified.
     */
    isVerified() {
        return this.verified;
    }
    /**
     * Check if the bot is spoofed.
     *
     * @returns
     *   Whether the bot is spoofed.
     */
    isSpoofed() {
        return this.spoofed;
    }
}
/**
 * Edge rule reason.
 *
 * @deprecated
 *   This reason is currently not used.
 */
class ArcjetEdgeRuleReason extends ArcjetReason {
    /**
     * Kind.
     */
    type = "EDGE_RULE";
}
/**
 * Shield reason.
 */
class ArcjetShieldReason extends ArcjetReason {
    /**
     * Kind.
     */
    type = "SHIELD";
    /**
     * Whether the shield was triggered.
     */
    shieldTriggered;
    /**
     * Create an `ArcjetShieldReason`.
     *
     * @param init
     *   Configuration.
     * @returns
     *   Shield reason.
     */
    constructor(init) {
        super();
        this.shieldTriggered = init.shieldTriggered ?? false;
    }
}
/**
 * Email reason.
 */
class ArcjetEmailReason extends ArcjetReason {
    /**
     * Kind.
     */
    type = "EMAIL";
    /**
     * List of email types that are allowed.
     */
    emailTypes;
    /**
     * Create an `ArcjetEmailReason`.
     *
     * @param init
     *   Configuration.
     * @returns
     *   Email reason.
     */
    constructor(init) {
        super();
        this.emailTypes = init.emailTypes ?? [];
    }
}
/**
 * Error reason.
 */
class ArcjetErrorReason extends ArcjetReason {
    /**
     * Kind.
     */
    type = "ERROR";
    /**
     * Error message.
     */
    message;
    /**
     * Create an `ArcjetErrorReason`.
     *
     * @param error
     *   Error that occurred.
     * @returns
     *   Error reason.
     */
    constructor(error) {
        super();
        // TODO: Get rid of instanceof check
        if (error instanceof Reason) {
            if (error.reason.case === "error") {
                this.message = error.reason.value.message;
                return;
            }
            else {
                this.message = "Missing error reason";
            }
        }
        // TODO: Get rid of instanceof check
        if (error instanceof Error) {
            this.message = error.message;
            return;
        }
        if (typeof error === "string") {
            this.message = error;
            return;
        }
        this.message = "Unknown error occurred";
    }
}
/**
 * Result of calling a rule.
 */
class ArcjetRuleResult {
    /**
     * Stable, deterministic, and unique identifier of the rule that generated
     * this result.
     */
    ruleId;
    /**
     * Fingerprint calculated for this rule, which can be used to cache the
     * result for the amount of time specified by `ttl`.
     */
    fingerprint;
    /**
     * Duration in seconds this result should be considered valid, also known
     * as time-to-live.
     */
    ttl;
    /**
     * State of the rule.
     */
    state;
    /**
     * Conclusion of the rule.
     */
    conclusion;
    /**
     * Reason for the conclusion.
     */
    reason;
    /**
     * Create an `ArcjetRuleResult`.
     *
     * @param init
     *   Configuration.
     * @returns
     *   Rule result.
     */
    constructor(init) {
        this.ruleId = init.ruleId;
        this.fingerprint = init.fingerprint;
        this.ttl = init.ttl;
        this.state = init.state;
        this.conclusion = init.conclusion;
        this.reason = init.reason;
    }
    /**
     * Check if the rule result is denied.
     *
     * @returns
     *   Whether the rule result is denied.
     */
    isDenied() {
        return this.conclusion === "DENY";
    }
}
/**
 * Info about an IP address.
 */
class ArcjetIpDetails {
    /**
     * Estimated latitude of the IP address within the `accuracyRadius` margin
     * of error.
     */
    latitude;
    /**
     * Estimated longitude of the IP address - see accuracy_radius for the
     * margin of error.
     */
    longitude;
    /**
     * Accuracy radius of the IP address location in kilometers.
     */
    accuracyRadius;
    /**
     * Timezone of the IP address.
     */
    timezone;
    /**
     * Postal code of the IP address.
     */
    postalCode;
    /**
     * City the IP address is located in.
     */
    city;
    /**
     * Region the IP address is located in.
     */
    region;
    /**
     * Country code the IP address is located in.
     */
    country;
    /**
     * Country name the IP address is located in.
     */
    countryName;
    /**
     * Continent code the IP address is located in.
     */
    continent;
    /**
     * Continent name the IP address is located in.
     */
    continentName;
    /**
     * AS number the IP address belongs to.
     */
    asn;
    /**
     * AS name the IP address belongs to.
     */
    asnName;
    /**
     * ASN domain the IP address belongs to.
     */
    asnDomain;
    /**
     * ASN type: ISP, hosting, business, or education
     */
    asnType;
    /**
     * ASN country code the IP address belongs to.
     */
    asnCountry;
    /**
     * Name of service the IP address belongs to.
     */
    service;
    /**
     * Create an `ArcjetIpDetails`.
     *
     * @param init
     *   Configuration.
     * @returns
     *   IP details.
     */
    constructor(init = {}) {
        this.latitude = init.latitude;
        this.longitude = init.longitude;
        this.accuracyRadius = init.accuracyRadius;
        this.timezone = init.timezone;
        this.postalCode = init.postalCode;
        this.city = init.city;
        this.region = init.region;
        this.country = init.country;
        this.countryName = init.countryName;
        this.continent = init.continent;
        this.continentName = init.continentName;
        this.asn = init.asn;
        this.asnName = init.asnName;
        this.asnDomain = init.asnDomain;
        this.asnType = init.asnType;
        this.asnCountry = init.asnCountry;
        this.service = init.service;
        // TypeScript creates symbols on the class when using `private` or `#`
        // identifiers for tracking these properties. We don't want to end up with
        // the same issues as Next.js with private symbols so we use
        // `Object.defineProperties` here and then `@ts-expect-error` when we access
        // the values. This is mostly to improve the editor experience, as props
        // starting with `_` are sorted to the top of autocomplete.
        Object.defineProperties(this, {
            _isHosting: {
                configurable: false,
                enumerable: false,
                writable: false,
                value: init.isHosting ?? false,
            },
            _isVpn: {
                configurable: false,
                enumerable: false,
                writable: false,
                value: init.isVpn ?? false,
            },
            _isProxy: {
                configurable: false,
                enumerable: false,
                writable: false,
                value: init.isProxy ?? false,
            },
            _isTor: {
                configurable: false,
                enumerable: false,
                writable: false,
                value: init.isTor ?? false,
            },
            _isRelay: {
                configurable: false,
                enumerable: false,
                writable: false,
                value: init.isRelay ?? false,
            },
        });
    }
    /**
     * Check if the IP address has geo `latitude` info.
     * This also implies that `accuracyRadius` is available.
     *
     * @returns
     *   Whether the IP address has latitude info.
     */
    hasLatitude() {
        return typeof this.latitude !== "undefined";
    }
    /**
     * Check if the IP address has geo `longitude` info.
     * This also implies that `accuracyRadius` is available.
     *
     * @returns
     *   Whether the IP address has longitude info.
     */
    hasLongitude() {
        return typeof this.longitude !== "undefined";
    }
    /**
     * Check if the IP address has geo accuracy radius info.
     * This also implies that `latitude` and `longitude` are available.
     *
     * @returns
     *   Whether the IP address has accuracy info.
     */
    hasAccuracyRadius() {
        return typeof this.accuracyRadius !== "undefined";
    }
    /**
     * Check if the IP address has timezone info.
     *
     * @returns
     *   Whether the IP address has timezone info.
     */
    hasTimezone() {
        return typeof this.timezone !== "undefined";
    }
    /**
     * Check if the IP address has postcal code info.
     *
     * @returns
     *   Whether the IP address has postcal code info.
     */
    hasPostalCode() {
        return typeof this.postalCode !== "undefined";
    }
    /**
     * Check if the IP address has city info.
     *
     * @returns
     *   Whether the IP address has city info.
     */
    // TODO: If we have city, what other data are we sure to have?
    hasCity() {
        return typeof this.city !== "undefined";
    }
    /**
     * Check if the IP address has region info.
     *
     * @returns
     *   Whether the IP address has region info.
     */
    // TODO: If we have region, what other data are we sure to have?
    hasRegion() {
        return typeof this.region !== "undefined";
    }
    /**
     * Check if the IP address has country info:
     * `countryName` and `country`.
     *
     * @returns
     *   Whether the IP address has country info.
     */
    // TODO: If we have country, should we also have continent?
    hasCountry() {
        return typeof this.country !== "undefined";
    }
    /**
     * Check if the IP address has continent info:
     * `continentName` and `continent`.
     *
     * @returns
     *   Whether the IP address has continent info.
     */
    hasContintent() {
        return typeof this.continent !== "undefined";
    }
    /**
     * Check if the IP address has ASN info.
     *
     * @deprecated
     *   Use `hasAsn()` instead.
     *
     * @returns
     *   Whether the IP address has ASN info.
     */
    hasASN() {
        return this.hasAsn();
    }
    /**
     * Check if the IP address has ASN info:
     * `asnCountry`, `asnDomain`, `asnName`, `asnType`, and `asn` fields.
     *
     * @returns
     *   Whether the IP address has ASN info.
     */
    hasAsn() {
        return typeof this.asn !== "undefined";
    }
    /**
     * Check if the IP address has a service.
     *
     * @returns
     *   Whether the IP address has a service.
     */
    hasService() {
        return typeof this.service !== "undefined";
    }
    /**
     * Check if the IP address belongs to a hosting provider.
     *
     * @returns
     *   Whether the IP address belongs to a hosting provider.
     */
    isHosting() {
        // @ts-expect-error because we attach this with Object.defineProperties
        return this._isHosting;
    }
    /**
     * Check if the IP address belongs to a VPN provider.
     *
     * @returns
     *   Whether the IP address belongs to a VPN provider.
     */
    isVpn() {
        // @ts-expect-error because we attach this with Object.defineProperties
        return this._isVpn;
    }
    /**
     * Check if the IP address belongs to a proxy provider.
     *
     * @returns
     *   Whether the IP address belongs to a proxy provider.
     */
    isProxy() {
        // @ts-expect-error because we attach this with Object.defineProperties
        return this._isProxy;
    }
    /**
     * Check if the IP address belongs to a Tor node.
     *
     * @returns
     *   Whether the IP address belongs to a Tor node.
     */
    isTor() {
        // @ts-expect-error because we attach this with Object.defineProperties
        return this._isTor;
    }
    /**
     * Check if the IP address belongs to a relay service.
     *
     * @returns
     *   Whether the IP address belongs to a relay service.
     */
    isRelay() {
        // @ts-expect-error because we attach this with Object.defineProperties
        return this._isRelay;
    }
}
/**
 * Decision returned by the Arcjet SDK.
 */
class ArcjetDecision {
    /**
     * Unique identifier of the decision.
     * This can be used to look up the decision in the Arcjet dashboard.
     */
    id;
    /**
     * Duration in milliseconds this decision should be considered valid, also
     * known as time-to-live.
     */
    ttl;
    /**
     * List of results from calling rules.
     * Can also be found by logging into the Arcjet dashboard and searching for the decision `id`.
     */
    results;
    /**
     * Details about the IP address that informed the `conclusion`.
     */
    ip;
    /**
     * Create an `ArcjetDecision`.
     *
     * @param init
     *   Configuration.
     * @returns
     *   Decision.
     */
    constructor(init) {
        if (typeof init.id === "string") {
            this.id = init.id;
        }
        else {
            this.id = typeid("lreq").toString();
        }
        this.results = init.results;
        this.ttl = init.ttl;
        this.ip = init.ip ?? new ArcjetIpDetails();
    }
    /**
     * Check if the decision is allowed.
     * This considers `ERROR` decisions as allowed too.
     *
     * @returns
     *   Whether the decision is allowed.
     */
    isAllowed() {
        return this.conclusion === "ALLOW" || this.conclusion === "ERROR";
    }
    /**
     * Check if the decision is denied.
     *
     * @returns
     *   Whether the decision is denied.
     */
    isDenied() {
        return this.conclusion === "DENY";
    }
    /**
     * Check if the decision is challenged.
     *
     * @returns
     *   Whether the decision is challenged.
     */
    isChallenged() {
        return this.conclusion === "CHALLENGE";
    }
    /**
     * Check if the decision is errored.
     * This does **not** consider `ALLOW` as errored.
     *
     * @returns
     *   Whether the decision is errored.
     */
    isErrored() {
        return this.conclusion === "ERROR";
    }
}
/**
 * Allow decision.
 */
class ArcjetAllowDecision extends ArcjetDecision {
    /**
     * Kind.
     */
    conclusion = "ALLOW";
    /**
     * Reason for decision.
     */
    reason;
    /**
     * Create an `ArcjetAllowDecision`.
     *
     * @param init
     *   Configuration.
     * @returns
     *   Allow decision.
     */
    constructor(init) {
        super(init);
        this.reason = init.reason;
    }
}
/**
 * Deny decision.
 */
class ArcjetDenyDecision extends ArcjetDecision {
    /**
     * Kind.
     */
    conclusion = "DENY";
    /**
     * Reason for decision.
     */
    reason;
    /**
     * Create an `ArcjetDenyDecision`.
     *
     * @param init
     *   Configuration.
     * @returns
     *   Deny decision.
     */
    constructor(init) {
        super(init);
        this.reason = init.reason;
    }
}
/**
 * Challenge decision.
 */
class ArcjetChallengeDecision extends ArcjetDecision {
    /**
     * Kind.
     */
    conclusion = "CHALLENGE";
    /**
     * Reason for decision.
     */
    reason;
    /**
     * Create an `ArcjetChallengeDecision`.
     *
     * @param init
     *   Configuration.
     * @returns
     *   Challenge decision.
     */
    constructor(init) {
        super(init);
        this.reason = init.reason;
    }
}
/**
 * Error decision.
 */
class ArcjetErrorDecision extends ArcjetDecision {
    /**
     * Kind.
     */
    conclusion = "ERROR";
    /**
     * Reason for decision.
     */
    reason;
    /**
     * Create an `ArcjetErrorDecision`.
     *
     * @param init
     *   Configuration.
     * @returns
     *   Error decision.
     */
    constructor(init) {
        super(init);
        this.reason = init.reason;
    }
}

export { ArcjetAllowDecision, ArcjetBotReason, ArcjetChallengeDecision, ArcjetDecision, ArcjetDenyDecision, ArcjetEdgeRuleReason, ArcjetEmailReason, ArcjetErrorDecision, ArcjetErrorReason, ArcjetFilterReason, ArcjetIpDetails, ArcjetRateLimitReason, ArcjetReason, ArcjetRuleResult, ArcjetSensitiveInfoReason, ArcjetShieldReason };
