import type { ArcjetRule, ArcjetMode, ArcjetLogger, ArcjetWellKnownBot, ArcjetBotCategory, ArcjetEmailType, ArcjetSensitiveInfoType } from "@arcjet/protocol";
import { ArcjetDecision } from "@arcjet/protocol";
import type { Client } from "@arcjet/protocol/client.js";
export * from "@arcjet/protocol";
type Simplify<T> = {
    [KeyType in keyof T]: T[KeyType];
} & {};
type UnionToIntersection<Union> = (Union extends unknown ? (distributedUnion: Union) => void : never) extends (mergedIntersection: infer Intersection) => void ? // The `& Union` is to allow indexing by the resulting type
Intersection & Union : never;
type IsNever<T> = [T] extends [never] ? true : false;
type LiteralCheck<T, LiteralType extends null | undefined | string | number | boolean | symbol | bigint> = IsNever<T> extends false ? [T] extends [LiteralType] ? [LiteralType] extends [T] ? false : true : false : false;
type IsStringLiteral<T> = LiteralCheck<T, string>;
/**
 * Configuration for the token bucket rate limit rule.
 *
 * @template Characteristics
 *   Characteristics to track a user by.
 */
export type TokenBucketRateLimitOptions<Characteristics extends readonly string[]> = {
    /**
     * Block mode of the rule (default: `"DRY_RUN"`).
     *
     * `"DRY_RUN"` will allow all requests while still providing access to the
     * rule results.
     * `"LIVE"` will block requests when the rate limit is exceeded.
     */
    mode?: ArcjetMode;
    /**
     * Characteristics to track a user by (default: global characteristics or `["src.ip"]`).
     */
    characteristics?: Characteristics;
    /**
     * Tokens to add to the bucket at each interval (required).
     *
     * For example, if you set `interval` to `60` and the `refillRate` to `10`,
     * the bucket will refill `10` tokens every `60` seconds.
     */
    refillRate: number;
    /**
     * Time interval for the refill rate (required).
     *
     * This can be a string like `"1m"` for one minute,
     * `"1h45m"` for 1 hour and 45 minutes,
     * or a number like `120` for 120 seconds.
     *
     * Valid string time units are `s` (seconds),
     * `m` (minutes),
     * `h` (hours), and
     * `d` (days).
     */
    interval: string | number;
    /**
     * Max tokens the bucket can hold (required).
     *
     * The bucket starts at this full capacity, and after being used, will refill
     * until it reaches full capacity.
     */
    capacity: number;
};
/**
 * Configuration for the fixed window rate limit rule.
 *
 * @template Characteristics
 *   Characteristics to track a user by.
 */
export type FixedWindowRateLimitOptions<Characteristics extends readonly string[]> = {
    /**
     * Block mode of the rule (default: `"DRY_RUN"`).
     *
     * `"DRY_RUN"` will allow all requests while still providing access to the
     * rule results.
     * `"LIVE"` will block requests when the rate limit is exceeded.
     */
    mode?: ArcjetMode;
    /**
     * Characteristics to track a user by (default: global characteristics or `["src.ip"]`).
     */
    characteristics?: Characteristics;
    /**
     * Fixed time window (required).
     *
     * This can be a string like `"1m"` for one minute,
     * `"1h45m"` for 1 hour and 45 minutes,
     * or a number like `120` for 120 seconds.
     *
     * Valid string time units are `s` (seconds),
     * `m` (minutes),
     * `h` (hours), and
     * `d` (days).
     */
    window: string | number;
    /**
     * Max requests allowed in the fixed time window (required).
     */
    max: number;
};
/**
 * Configuration for the sliding window rate limit rule.
 *
 * @template Characteristics
 *   Characteristics to track a user by.
 */
export type SlidingWindowRateLimitOptions<Characteristics extends readonly string[]> = {
    /**
     * Block mode of the rule (default: `"DRY_RUN"`).
     *
     * `"DRY_RUN"` will allow all requests while still providing access to the
     * rule results.
     * `"LIVE"` will block requests when the rate limit is exceeded.
     */
    mode?: ArcjetMode;
    /**
     * Characteristics to track a user by (default: global characteristics or `["src.ip"]`).
     */
    characteristics?: Characteristics;
    /**
     * Time interval for the rate limit (required).
     *
     * This can be a string like `"1m"` for one minute,
     * `"1h45m"` for 1 hour and 45 minutes,
     * or a number like `120` for 120 seconds.
     *
     * Valid string time units are `s` (seconds),
     * `m` (minutes),
     * `h` (hours), and
     * `d` (days).
     */
    interval: string | number;
    /**
     * Max requests allowed in the sliding time window (required).
     */
    max: number;
};
/**
 * Configuration for the bot detection rule to allow certain bots and deny
 * others.
 */
export type BotOptionsAllow = {
    /**
     * Block mode of the rule (default: `"DRY_RUN"`).
     *
     * `"DRY_RUN"` will allow all requests while still providing access to the
     * rule results.
     * `"LIVE"` will block requests when the rate limit is exceeded.
     */
    mode?: ArcjetMode;
    /**
     * List of bots to allow (required).
     *
     * Only the bots in this list will be allowed and any other detected bot will
     * be denied.
     * All bots will be denied if empty.
     * You must provide either `allow` or `deny`, not both.
     *
     * You can use an individual bot name such as `"CURL"` to allow the default
     * user-agent of the `curl` tool.
     * You can also use bot categories such as `"CATEGORY:SEARCH_ENGINE"` to allow
     * all search engine bots.
     * See [*Identifying bots* on
     * `docs.arcjet.com`](https://docs.arcjet.com/bot-protection/identifying-bots)
     * for a list of bots and categories.
     */
    allow: Array<ArcjetWellKnownBot | ArcjetBotCategory>;
    /**
     * List of bots to deny,
     * cannot be combined with `allow`.
     */
    deny?: never;
};
/**
 * Configuration for the bot detection rule to deny certain bots and allow
 * others.
 */
export type BotOptionsDeny = {
    /**
     * Block mode of the rule (default: `"DRY_RUN"`).
     *
     * `"DRY_RUN"` will allow all requests while still providing access to the
     * rule results.
     * `"LIVE"` will block requests when the rate limit is exceeded.
     */
    mode?: ArcjetMode;
    /**
     * List of bots to allow,
     * cannot be combined with `allow`.
     */
    allow?: never;
    /**
     * List of bots to deny (required).
     *
     * Only the bots in this list will be denied and any other detected bot will
     * be allowed.
     * All bots will be allowed if empty, which is equivalent to not using
     * `detectBot()`.
     * You must provide either `allow` or `deny`, not both.
     *
     * You can use an individual bot name such as `"CURL"` to deny the default
     * user-agent of the `curl` tool.
     * You can also use bot categories such as `"CATEGORY:SEARCH_ENGINE"` to deny
     * all search engine bots.
     * See [*Identifying bots* on
     * `docs.arcjet.com`](https://docs.arcjet.com/bot-protection/identifying-bots)
     * for a list of bots and categories.
     */
    deny: Array<ArcjetWellKnownBot | ArcjetBotCategory>;
};
/**
 * Configuration for the bot detection rule.
 */
export type BotOptions = BotOptionsAllow | BotOptionsDeny;
/**
 * Configuration for the email validation rule to allow certain email addresses
 * and deny others.
 */
export type EmailOptionsAllow = {
    /**
     * Block mode of the rule (default: `"DRY_RUN"`).
     *
     * `"DRY_RUN"` will allow all requests while still providing access to the
     * rule results.
     * `"LIVE"` will block requests when the rate limit is exceeded.
     */
    mode?: ArcjetMode;
    /**
     * List of email address types to allow (required).
     *
     * Only email addresses of the email types in this list will be allowed and
     * any other address will be denied.
     * All addresses will be denied if empty.
     * You must provide either `allow` or `deny`, not both.
     *
     * You can use the following email types:
     *
     * - `"DISPOSABLE"` (disposable email addresses)
     * - `"FREE"` (free email addresses)
     * - `"NO_GRAVATAR"` (email addresses with no Gravatar)
     * - `"NO_MX_RECORDS"` (email addresses with no MX records)
     * - `"INVALID"` (invalid email addresses)
     */
    allow: ArcjetEmailType[];
    /**
     * List of email address types to block,
     * cannot be combined with `allow`.
     *
     * @deprecated
     *   Use `deny` instead.
     */
    block?: never;
    /**
     * List of email address types to deny,
     * cannot be combined with `allow`.
     */
    deny?: never;
    /**
     * Whether to see email addresses that contain a single domain segment as
     * invalid (default: `true`).
     *
     * For example, `foo@bar` is seen as valid when `false` and invalid when
     * `true`.
     */
    requireTopLevelDomain?: boolean;
    /**
     * Whether to see email addresses that contain a domain literal as valid
     * (default: `false`).
     *
     * For example, `foo@[192.168.1.1]` is valid when `true` and invalid when
     * `false`.
     */
    allowDomainLiteral?: boolean;
};
/**
 * Configuration for the email validation rule to deny certain email addresses
 * and allow others.
 */
export type EmailOptionsDeny = {
    /**
     * Block mode of the rule (default: `"DRY_RUN"`).
     *
     * `"DRY_RUN"` will allow all requests while still providing access to the
     * rule results.
     * `"LIVE"` will block requests when the rate limit is exceeded.
     */
    mode?: ArcjetMode;
    /**
     * List of email address types to allow,
     * cannot be combined with `deny`.
     */
    allow?: never;
    /**
     * List of email address types to block,
     * cannot be combined with `deny`.
     *
     * @deprecated
     *   Use `deny` instead.
     */
    block?: never;
    /**
     * List of email address types to deny (required).
     *
     * Email addresses of the email types in this list will be denied and
     * any other address will be allowed.
     * All addresses will be allowed if empty.
     * You must provide either `allow` or `deny`, not both.
     *
     * You can use the following email types:
     *
     * - `"DISPOSABLE"` (disposable email addresses)
     * - `"FREE"` (free email addresses)
     * - `"NO_GRAVATAR"` (email addresses with no Gravatar)
     * - `"NO_MX_RECORDS"` (email addresses with no MX records)
     * - `"INVALID"` (invalid email addresses)
     */
    deny: ArcjetEmailType[];
    /**
     * Whether to see email addresses that contain a single domain segment as
     * invalid (default: `true`).
     *
     * For example, `foo@bar` is seen as valid when `false` and invalid when
     * `true`.
     */
    requireTopLevelDomain?: boolean;
    /**
     * Whether to see email addresses that contain a domain literal as valid
     * (default: `false`).
     *
     * For example, `foo@[192.168.1.1]` is valid when `true` and invalid when
     * `false`.
     */
    allowDomainLiteral?: boolean;
};
/**
 * Configuration for the email validation rule to deny certain email addresses
 * and allow others.
 *
 * @deprecated
 *   Use `deny` instead.
 */
type EmailOptionsBlock = {
    /**
     * Block mode of the rule (default: `"DRY_RUN"`).
     */
    mode?: ArcjetMode;
    /**
     * List of email address types to allow,
     * cannot be combined with `block`.
     */
    allow?: never;
    /**
     * List of email address types to deny (required).
     *
     * @deprecated
     *   Use `deny` instead.
     */
    block: ArcjetEmailType[];
    deny?: never;
    /**
     * Whether to see email addresses that contain a single domain segment as
     * invalid (default: `true`).
     */
    requireTopLevelDomain?: boolean;
    /**
     * Whether to see email addresses that contain a domain literal as valid
     * (default: `false`).
     */
    allowDomainLiteral?: boolean;
};
/**
 * Configuration for the email validation rule.
 */
export type EmailOptions = EmailOptionsAllow | EmailOptionsDeny | EmailOptionsBlock;
/**
 * Custom detection function to identify sensitive information.
 *
 * This signature corresponds to similar functions from `@arcjet/redact-wasm`
 * and `@arcjet/redact`.
 *
 * @template T
 *   Custom entity names that are returned from `detect` and optionally listed in `entities`.
 * @param tokens
 *   Tokens to detect in.
 * @returns
 *   Array of `undefined` for tokens that are not sensitive or a `string` used as
 *   a label for sensitive info.
 */
type DetectSensitiveInfoEntities<T> = (tokens: string[]) => Array<ArcjetSensitiveInfoType | T | undefined>;
type ValidEntities<Detect> = Array<undefined extends Detect ? ArcjetSensitiveInfoType : Detect extends DetectSensitiveInfoEntities<infer CustomEntities> ? ArcjetSensitiveInfoType | CustomEntities : never>;
/**
 * Configuration for the sensitive info detection rule to allow certain
 * sensitive info types and deny others.
 *
 * @template Detect
 *   Custom detection function to identify sensitive information.
 */
export type SensitiveInfoOptionsAllow<Detect> = {
    /**
     * List of sensitive info types to allow (required).
     *
     * Only the types in this list will be allowed and any other detected types
     * will be denied.
     * All sensitive info (including that detected by `detect`) will be denied if
     * empty.
     * You must provide either `allow` or `deny`, not both.
     *
     * You can use the following sensitive info types that can be detected
     * natively:
     *
     * - `"CREDIT_CARD_NUMBER"`
     * - `"EMAIL"`
     * - `"IP_ADDRESS"`
     * - `"PHONE_NUMBER"`
     *
     * You can also use labels of custom info detected by `detect`.
     */
    allow: ValidEntities<Detect>;
    /**
     * List of sensitive info types to deny,
     * cannot be combined with `allow`.
     */
    deny?: never;
    /**
     * Tokens to consider (default: `1`).
     *
     * A list of tokens of this size will be passed to the custom detect
     * function.
     */
    contextWindowSize?: number;
    /**
     * Block mode of the rule (default: `"DRY_RUN"`).
     *
     * `"DRY_RUN"` will allow all requests while still providing access to the
     * rule results.
     * `"LIVE"` will block requests when the rate limit is exceeded.
     */
    mode?: ArcjetMode;
    /**
     * Custom detection function to identify sensitive information.
     */
    detect?: Detect;
};
/**
 * Configuration for the sensitive info detection rule to deny certain
 * sensitive info types and allow others.
 *
 * @template Detect
 *   Custom detection function to identify sensitive information.
 */
export type SensitiveInfoOptionsDeny<Detect> = {
    /**
     * List of sensitive info types to allow,
     * cannot be combined with `deny`.
     */
    allow?: never;
    /**
     * List of sensitive info types to deny (required).
     *
     * Only the types in this list will be denied and any other detected types
     * will be allowed.
     * All sensitive info (including that detected by `detect`) will be allowed if
     * empty.
     * You must provide either `allow` or `deny`, not both.
     *
     * You can use the following sensitive info types that can be detected
     * natively:
     *
     * - `"CREDIT_CARD_NUMBER"`
     * - `"EMAIL"`
     * - `"IP_ADDRESS"`
     * - `"PHONE_NUMBER"`
     *
     * You can also use labels of custom info detected by `detect`.
     */
    deny: ValidEntities<Detect>;
    /**
     * Tokens to consider (default: `1`).
     *
     * A list of tokens of this size will be passed to the custom detect
     * function.
     */
    contextWindowSize?: number;
    /**
     * Block mode of the rule (default: `"DRY_RUN"`).
     *
     * `"DRY_RUN"` will allow all requests while still providing access to the
     * rule results.
     * `"LIVE"` will block requests when the rate limit is exceeded.
     */
    mode?: ArcjetMode;
    /**
     * Custom detection function to identify sensitive information.
     */
    detect?: Detect;
};
/**
 * Configuration for the sensitive info detection rule.
 *
 * @template Detect
 *   Custom detection function to identify sensitive information.
 */
export type SensitiveInfoOptions<Detect> = SensitiveInfoOptionsAllow<Detect> | SensitiveInfoOptionsDeny<Detect>;
/**
 * Configuration to allow if a filter matches and deny otherwise.
 */
export type FilterOptionsAllow = {
    /**
     * Expressions.
     */
    allow: ReadonlyArray<string>;
    /**
     * Expressions,
     * must not be set if `allow` is set.
     */
    deny?: never;
    /**
     * Mode.
     */
    mode?: ArcjetMode | undefined;
};
/**
 * Configuration to deny if a filter matches and allow otherwise.
 */
export type FilterOptionsDeny = {
    /**
     * Expressions,
     * must not be set if `deny` is set.
     */
    allow?: never;
    /**
     * Expressions.
     */
    deny: ReadonlyArray<string>;
    /**
     * Mode.
     */
    mode?: ArcjetMode | undefined;
};
/**
 * Configuration for `filter` rule.
 */
export type FilterOptions = FilterOptionsAllow | FilterOptionsDeny;
type PlainObject = {
    [key: string]: unknown;
};
/**
 * Arcjet provides a set of key primitives which can be used to build security
 * functionality.
 * Each primitive can be used independently or combined as part of a
 * pre-configured product.
 *
 * @template Props
 *   Configuration.
 */
export type Primitive<Props extends PlainObject = {}> = [ArcjetRule<Props>];
/**
 * Pre-configured product consisting of combined primitives.
 *
 * @template Props
 *   Configuration.
 */
export type Product<Props extends PlainObject = {}> = ArcjetRule<Props>[];
type PropsForCharacteristic<T> = IsStringLiteral<T> extends true ? T extends "ip.src" | "http.host" | "http.method" | "http.request.uri.path" | `http.request.headers["${string}"]` | `http.request.cookie["${string}"]` | `http.request.uri.args["${string}"]` ? {} : T extends string ? Record<T, string | number | boolean> : never : {};
/**
 * Props for characteristics.
 *
 * Utility type to generate a record of props for each characteristic.
 * It excludes the known characteristics which Arcjet provides.
 *
 * @template Characteristics
 *   List of characteristics.
 */
export type CharacteristicProps<Characteristics extends readonly string[]> = UnionToIntersection<PropsForCharacteristic<Characteristics[number]>>;
type PropsForRule<R> = R extends ArcjetRule<infer Props> ? Props : {};
/**
 * Props for rules.
 *
 * Utility type to generate a record of props for all rules.
 *
 * @template Rules
 *   Matrix or list of rules.
 */
export type ExtraProps<Rules> = Rules extends [] ? {} : Rules extends ArcjetRule[][] ? UnionToIntersection<PropsForRule<Rules[number][number]>> : Rules extends ArcjetRule[] ? UnionToIntersection<PropsForRule<Rules[number]>> : never;
/**
 * Additional context provided by adapters.
 */
export type ArcjetAdapterContext = {
    /**
     * Allow arbitrary indexing.
     *
     * Adapters could include the Arcjet API Key if it were only available in a
     * runtime handler or IP details provided by a platform.
     */
    [key: string]: unknown;
    /**
     * Read the request body (required).
     */
    getBody(): Promise<string | undefined>;
    /**
     * Wait for a promise to resolve before continuing (optional).
     *
     * @param promise
     *   The promise to wait for.
     * @returns
     *   Nothing.
     */
    waitUntil?: (promise: Promise<unknown>) => void;
};
/**
 * Arcjet request.
 *
 * @template Props
 *   Extra data that might be useful for Arcjet.
 *   For example, requested tokens are specified as the `requested` property.
 */
export type ArcjetRequest<Props extends PlainObject> = Simplify<{
    /**
     * Additional properties.
     *
     * For example, an email address related to the request is commonly passed
     * as `email` (`string`).
     */
    [key: string]: unknown;
    /**
     * IP address of the client.
     */
    ip?: string;
    /**
     * HTTP method of the request.
     */
    method?: string;
    /**
     * Protocol of the request.
     */
    protocol?: string;
    /**
     * Host of the request.
     */
    host?: string;
    /**
     * Path of the request.
     */
    path?: string;
    /**
     * Headers of the request.
     */
    headers?: Headers | Record<string, string | string[] | undefined>;
    /**
     * Semicolon-separated cookies for a request.
     */
    cookies?: string;
    /**
     * Query string for a request.
     * Commonly referred to as a "querystring".
     * Starts with `?` when not empty.
     */
    query?: string;
} & Props>;
/**
 * Arcjet token bucket rate limiting rule.
 *
 * Applying this rule sets a token bucket rate limit.
 *
 * This algorithm is based on a bucket filled with a specific number of tokens.
 * Each request withdraws some amount of tokens from the bucket and the bucket
 * is refilled at a fixed rate.
 * Once the bucket is empty, the client is blocked until the bucket refills.
 *
 * This algorithm is useful when you want to allow clients to make a burst of
 * requests and then still be able to make requests at a slower rate.
 *
 * @template Characteristics
 *   Characteristics to track a user by.
 * @param options
 *   Configuration for the token bucket rate limiting rule (required).
 * @returns
 *   Token bucket rule to provide to the SDK in the `rules` field.
 *
 * @example
 *   ```ts
 *   tokenBucket({
 *     mode: "LIVE",
 *     refillRate: 10,
 *     interval: "60s",
 *     capacity: 100,
 *   });
 *   ```
 * @example
 *   ```ts
 *   const aj = arcjet({
 *     key: process.env.ARCJET_KEY,
 *     rules: [
 *       tokenBucket({
 *         mode: "LIVE",
 *         refillRate: 10,
 *         interval: "60s",
 *         capacity: 100,
 *       }),
 *     ],
 *   });
 *   ```
 *
 * @link https://docs.arcjet.com/rate-limiting/concepts
 * @link https://docs.arcjet.com/rate-limiting/algorithms#token-bucket
 * @link https://docs.arcjet.com/rate-limiting/reference
 */
export declare function tokenBucket<const Characteristics extends readonly string[] = []>(options: TokenBucketRateLimitOptions<Characteristics>): Primitive<Simplify<UnionToIntersection<{
    requested: number;
} | CharacteristicProps<Characteristics>>>>;
/**
 * Arcjet fixed window rate limiting rule.
 *
 * Applying this rule sets a fixed window rate limit which tracks the number of
 * requests made by a client over a fixed time window.
 *
 * This is the simplest algorithm.
 * It tracks the number of requests made by a client over a fixed time window
 * such as 60 seconds.
 * If the client exceeds the limit, they are blocked until the window expires.
 *
 * This algorithm is useful when you want to apply a simple fixed limit in a
 * fixed time window.
 * For example, a simple limit on the total number of requests a client can make.
 * However, it can be susceptible to the stampede problem where a client makes
 * a burst of requests at the start of a window and then is blocked for the rest
 * of the window.
 * The sliding window algorithm can be used to avoid this.
 *
 * @template Characteristics
 *   Characteristics to track a user by.
 * @param options
 *   Configuration for the fixed window rate limiting rule (required).
 * @returns
 *   Fixed window rule to provide to the SDK in the `rules` field.
 *
 * @example
 *   ```ts
 *   fixedWindow({ mode: "LIVE", window: "60s", max: 100 });
 *   ```
 * @example
 *   ```ts
 *   const aj = arcjet({
 *      key: process.env.ARCJET_KEY,
 *     rules: [
 *       fixedWindow({
 *         mode: "LIVE",
 *         window: "60s",
 *         max: 100,
 *       })
 *     ],
 *   });
 *   ```
 *
 * @link https://docs.arcjet.com/rate-limiting/concepts
 * @link https://docs.arcjet.com/rate-limiting/algorithms#fixed-window
 * @link https://docs.arcjet.com/rate-limiting/reference
 */
export declare function fixedWindow<const Characteristics extends readonly string[] = []>(options: FixedWindowRateLimitOptions<Characteristics>): Primitive<Simplify<CharacteristicProps<Characteristics>>>;
/**
 * Arcjet sliding window rate limiting rule.
 *
 * Applying this rule sets a sliding window rate limit which tracks the number
 * of requests made by a client over a sliding window so that the window moves
 * with time.
 *
 * This algorithm is useful to avoid the stampede problem of the fixed window.
 * It provides smoother rate limiting over time and can prevent a client from
 * making a burst of requests at the start of a window and then being blocked
 * for the rest of the window.
 *
 * @template Characteristics
 *   Characteristics to track a user by.
 * @param options
 *   Configuration for the sliding window rate limiting rule (required).
 * @returns
 *   Token bucket rule to provide to the SDK in the `rules` field.
 *
 * @example
 *   ```ts
 *   slidingWindow({ mode: "LIVE", interval: "60s", max: 100 });
 *   ```
 * @example
 *   ```ts
 *   const aj = arcjet({
 *     key: process.env.ARCJET_KEY,
 *     rules: [
 *       slidingWindow({
 *         mode: "LIVE",
 *         interval: "60s",
 *         max: 100,
 *       })
 *     ],
 *   });
 *   ```
 *
 * @link https://docs.arcjet.com/rate-limiting/concepts
 * @link https://docs.arcjet.com/rate-limiting/algorithms#sliding-window
 * @link https://docs.arcjet.com/rate-limiting/reference
 */
export declare function slidingWindow<const Characteristics extends readonly string[] = []>(options: SlidingWindowRateLimitOptions<Characteristics>): Primitive<Simplify<CharacteristicProps<Characteristics>>>;
/**
 * Arcjet sensitive information detection rule.
 *
 * Applying this rule protects against clients sending you sensitive information
 * such as personally identifiable information (PII) that you do not wish to
 * handle.
 * The rule runs entirely locally so no data ever leaves your environment.
 *
 * This rule includes built-in detections for email addresses, credit/debit card
 * numbers, IP addresses, and phone numbers.
 * You can also provide a custom detection function to identify additional
 * sensitive information.
 *
 * @template Detect
 *   Custom detection function to identify sensitive information.
 * @template CustomEntities
 *   Custom entities.
 * @param options
 *   Configuration for the sensitive information detection rule (required).
 * @returns
 *   Sensitive information rule to provide to the SDK in the `rules` field.
 *
 * @example
 *   ```ts
 *   sensitiveInfo({ mode: "LIVE", deny: ["EMAIL"] });
 *   ```
 * @example
 *   ```ts
 *   const aj = arcjet({
 *     key: process.env.ARCJET_KEY,
 *     rules: [
 *       sensitiveInfo({
 *         mode: "LIVE",
 *         deny: ["EMAIL"],
 *       })
 *     ],
 *   });
 *   ```
 * @example
 *   Custom detection function:
 *
 *   ```ts
 *   function detectDash(tokens: string[]): Array<"CONTAINS_DASH" | undefined> {
 *     return tokens.map((token) => {
 *       if (token.includes("-")) {
 *         return "CONTAINS_DASH";
 *       }
 *     });
 *   }
 *
 *   const aj = arcjet({
 *     key: process.env.ARCJET_KEY,
 *     rules: [
 *       sensitiveInfo({
 *         mode: "LIVE",
 *         deny: ["EMAIL", "CONTAINS_DASH"],
 *         detect: detectDash,
 *         contextWindowSize: 2,
 *       })
 *     ],
 *   });
 *   ```
 *
 * @link https://docs.arcjet.com/sensitive-info/concepts
 * @link https://docs.arcjet.com/sensitive-info/reference
 */
export declare function sensitiveInfo<const Detect extends DetectSensitiveInfoEntities<CustomEntities> | undefined, const CustomEntities extends string>(options: SensitiveInfoOptions<Detect>): Primitive<{}>;
/**
 * Arcjet email validation rule.
 *
 * Applying this rule allows you to validate and verify an email address.
 *
 * The first step of the analysis is to validate the email address syntax.
 * This runs locally within the SDK and validates the email address is in the
 * correct format.
 * If the email syntax is valid, the SDK will pass the email address to the
 * Arcjet cloud API to verify the email address.
 * This performs several checks, depending on the rule configuration.
 *
 * @param options
 *   Configuration for the email validation rule (required).
 * @returns
 *   Email rule to provide to the SDK in the `rules` field.
 *
 * @example
 *   ```ts
 *   validateEmail({ mode: "LIVE", deny: ["DISPOSABLE", "INVALID"] });
 *   ```
 * @example
 *   ```ts
 *   const aj = arcjet({
 *     key: process.env.ARCJET_KEY,
 *     rules: [
 *       validateEmail({
 *         mode: "LIVE",
 *         deny: ["DISPOSABLE", "INVALID"]
 *       })
 *     ],
 *   });
 *   ```
 *
 * @link https://docs.arcjet.com/email-validation/concepts
 * @link https://docs.arcjet.com/email-validation/reference
 */
export declare function validateEmail(options: EmailOptions): Primitive<{
    email: string;
}>;
/**
 * Arcjet bot detection rule.
 *
 * Applying this rule allows you to manage traffic by automated clients and
 * bots.
 *
 * Bots can be good (such as search engine crawlers or monitoring agents) or bad
 * (such as scrapers or automated scripts).
 * Arcjet allows you to configure which bots you want to allow or deny by
 * specific bot names such as curl, as well as by category such as search
 * engine bots.
 *
 * Bots are detected based on various signals such as the user agent, IP
 * address, DNS records, and more.
 *
 * @param options
 *   Configuration for the bot rule (required).
 * @returns
 *   Bot rule to provide to the SDK in the `rules` field.
 *
 * @example
 *   Allow search engine bots and curl, deny all other bots:
 *
 *   ```ts
 *   detectBot({ mode: "LIVE", allow: ["CATEGORY:SEARCH_ENGINE", "CURL"] });
 *   ```
 * @example
 *   Allow search engine bots and curl, deny all other bots:
 *
 *   ```ts
 *   const aj = arcjet({
 *     key: process.env.ARCJET_KEY,
 *     rules: [
 *       detectBot({
 *         mode: "LIVE",
 *         allow: ["CATEGORY:SEARCH_ENGINE", "CURL"]
 *       })
 *     ],
 *   });
 *   ```
 * @example
 *   Deny AI crawlers, allow all other bots:
 *
 *   ```ts
 *   detectBot({ mode: "LIVE", deny: ["CATEGORY:AI"] });
 *   ```
 * @example
 *   Deny AI crawlers, allows all other bots:
 *
 *   ```ts
 *   const aj = arcjet({
 *     key: process.env.ARCJET_KEY,
 *     rules: [
 *       detectBot({
 *         mode: "LIVE",
 *         deny: ["CATEGORY:AI"]
 *       })
 *     ],
 *   });
 *   ```
 *
 * @link https://docs.arcjet.com/bot-protection/concepts
 * @link https://docs.arcjet.com/bot-protection/identifying-bots
 * @link https://docs.arcjet.com/bot-protection/reference
 */
export declare function detectBot(options: BotOptions): Primitive<{}>;
/**
 * Configuration for the Shield WAF rule.
 */
export type ShieldOptions = {
    /**
     * Block mode of the rule (default: `"DRY_RUN"`).
     *
     * `"DRY_RUN"` will allow all requests while still providing access to the
     * rule results.
     * `"LIVE"` will block requests when the rate limit is exceeded.
     */
    mode?: ArcjetMode;
};
/**
 * Arcjet Shield WAF rule.
 *
 * Applying this rule protects your application against common attacks,
 * including the OWASP Top 10.
 *
 * The Arcjet Shield WAF analyzes every request to your application to detect
 * suspicious activity.
 * Once a certain suspicion threshold is reached,
 * subsequent requests from that client are blocked for a period of time.
 *
 * @param options
 *   Configuration for the Shield rule.
 * @returns
 *   Shield rule to provide to the SDK in the `rules` field.
 *
 * @example
 *   ```ts
 *   shield({ mode: "LIVE" });
 *   ```
 * @example
 *   ```ts
 *   const aj = arcjet({
 *     key: process.env.ARCJET_KEY,
 *     rules: [shield({ mode: "LIVE" })],
 *   });
 *   ```
 *
 * @link https://docs.arcjet.com/shield/concepts
 * @link https://docs.arcjet.com/shield/reference
 */
export declare function shield(options: ShieldOptions): Primitive<{}>;
/**
 * Configuration for signup form protection rule.
 *
 * @template Characteristics
 *   Characteristics to track a user by.
 */
export type ProtectSignupOptions<Characteristics extends readonly string[]> = {
    /**
     * Configuration for rate limit rule (required).
     */
    rateLimit: SlidingWindowRateLimitOptions<Characteristics>;
    /**
     * Configuration for bot protection rule (required).
     */
    bots: BotOptions;
    /**
     * Configuration for email validation rule (required).
     */
    email: EmailOptions;
};
/**
 * Arcjet signup form protection rule.
 *
 * Applying this rule combines rate limiting, bot protection, and email
 * validation to protect your signup forms from abuse.
 * Using this rule will configure the following:
 *
 * - Rate limiting - signup forms are a common target for bots. Arcjet’s rate
 *   limiting helps to prevent bots and other automated or malicious clients
 *   from submitting your signup form too many times in a short period of time.
 * - Bot protection - signup forms are usually exclusively used by humans, which
 *   means that any automated submissions to the form are likely to be
 *   fraudulent.
 * - Email validation - email addresses should be validated to ensure the signup
 *   is coming from a legitimate user with a real email address that can
 *   actually receive messages.
 *
 * @template Characteristics
 *   Characteristics to track a user by.
 * @param options
 *   Configuration for the signup form protection rule.
 * @returns
 *   Signup form protection rule to provide to the SDK in the `rules` field.
 *
 * @example
 *   Our recommended configuration for most signup forms is:
 *
 *   - Block email addresses with invalid syntax, that are from disposable email providers,
 *     or do not have valid MX records configured.
 *   - Block all bots.
 *   - Apply a rate limit of 5 submissions per 10 minutes from a single IP
 *     address.
 *
 *   ```ts
 *   const aj = arcjet({
 *     key: process.env.ARCJET_KEY,
 *     rules: [
 *      protectSignup({
 *        email: {
 *          mode: "LIVE",
 *          block: ["DISPOSABLE", "INVALID", "NO_MX_RECORDS"],
 *        },
 *        bots: {
 *          mode: "LIVE",
 *          allow: [], // block all detected bots
 *        },
 *        rateLimit: {
 *          mode: "LIVE",
 *          interval: "10m",
 *          max: 5,
 *        },
 *      }),
 *    ],
 *   });
 *   ```
 *
 * @link https://docs.arcjet.com/signup-protection/concepts
 * @link https://docs.arcjet.com/signup-protection/reference
 */
export declare function protectSignup<const Characteristics extends string[] = []>(options: ProtectSignupOptions<Characteristics>): Product<Simplify<UnionToIntersection<{
    email: string;
} | CharacteristicProps<Characteristics>>>>;
/**
 * Arcjet filter rule.
 *
 * Applying this rule lets you block requests using Wireshark-like display
 * filter expressions over HTTP headers, IP addresses, and other request
 * fields.
 * You can quickly enforce rules like allow/deny by country, network, or
 * `user-agent` pattern.
 *
 * See the [reference guide](https://docs.arcjet.com/filters/reference) for
 * more info on the expression language fields, functions, and values.
 *
 * @param options
 *   Configuration (required).
 * @returns
 *   Filter rule.
 *
 * @example
 *   In this example, the expression matches non-VPN GET requests from the US.
 *   Requests matching the expression are allowed, all others are denied.
 *
 *   ```ts
 *   filter({
 *     allow: [
 *       'http.request.method eq "GET" and ip.src.country eq "US" and not ip.src.vpn',
 *     ],
 *     mode: "LIVE",
 *   })
 *   ```
 *
 * @link https://docs.arcjet.com/filters/reference
 */
export declare function filter(options: FilterOptions): Primitive<{}>;
/**
 * Configuration for Arcjet.
 *
 * @template Rules
 *   List of rules.
 * @template Characteristics
 *   Characteristics to track a user by.
 */
export interface ArcjetOptions<Rules extends [...(Primitive | Product)[]], Characteristics extends readonly string[]> {
    /**
     * API key to identify the site in Arcjet (required).
     */
    key: string;
    /**
     * Rules to apply when protecting a request (required).
     */
    rules: readonly [...Rules];
    /**
     * Characteristics to track a user by (default: `["src.ip"]`).
     * Can also be passed to rules.
     */
    characteristics?: Characteristics;
    /**
     * Client used to make requests to the Arcjet API (optional).
     *
     * This should not be passed by end users but is configured by integrations
     * (such as `@arcjet/next`) or for testing purposes.
     */
    client?: Client;
    /**
     * Log interface to emit useful information from the SDK (optional).
     */
    log?: ArcjetLogger;
}
/**
 * Arcjet instance.
 *
 * Primarily has a `protect()` method to make a decision about how a request
 * should be handled.
 */
export interface Arcjet<Props extends PlainObject> {
    /**
     * Make a decision about how to handle a request.
     *
     * This will analyze the request locally where possible and otherwise call
     * the Arcjet decision API.
     *
     * @param ctx
     *   Additional context for this function call.
     * @param request
     *   Details about the {@linkcode ArcjetRequest} that Arcjet needs to make a
     *   decision.
     * @returns
     *   Promise that resolves to an {@linkcode ArcjetDecision} indicating
     *   Arcjet’s decision about the request.
     */
    protect(ctx: ArcjetAdapterContext, request: ArcjetRequest<Props>): Promise<ArcjetDecision>;
    /**
     * Augment the client with another rule.
     *
     * Useful for varying rules based on criteria in your handler such as
     * different rate limit for logged in users.
     *
     * @param rule
     *   Rule to add to Arcjet.
     * @returns
     *   Arcjet instance augmented with the given rule.
     */
    withRule<Rule extends Primitive | Product>(rule: Rule): Arcjet<Simplify<Props & ExtraProps<Rule>>>;
}
/**
 * Create a new Arcjet instance.
 *
 * @template Rules
 *   List of rules.
 * @template Characteristics
 *   Characteristics to track a user by.
 * @param options
 *   Configuration.
 * @returns
 *   Arcjet instance.
 */
export default function arcjet<const Rules extends [...(Primitive | Product)[]] = [], const Characteristics extends readonly string[] = []>(options: ArcjetOptions<Rules, Characteristics>): Arcjet<Simplify<ExtraProps<Rules> & CharacteristicProps<Characteristics>>>;
